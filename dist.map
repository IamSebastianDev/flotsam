{"version":3,"file":"dist","sources":["src/utils/safeAsyncAbort.util.ts","src/utils/root.util.ts","src/utils/isTruthy.util.ts","src/utils/sortByProperty.util.ts","src/lib/ObjectId.ts","src/lib/JSONDocument.ts","src/lib/Queue.ts","src/lib/evaluateFindOptions.ts","src/lib/Crypto.ts","src/lib/Collection.ts","src/lib/Loq.ts","src/lib/Flotsam.ts"],"sourcesContent":["/** @format */\n\nimport { Rejector } from '../types';\n\n/**\n * @description\n * Utility function to safely execute an operation and rejecting a outer Promise when an error is caught.\n *\n * @param { Rejector } rejector - the function used to reject the outer Promise when an error is caught\n * @param { (...args: any[]) => Promise<any> } operation - the operation to perform\n *\n * @returns { Promise<void> }\n */\n\nexport const safeAsyncAbort = async <T extends (...args: any[]) => Promise<any>>(\n    rejector: Rejector,\n    operation: T\n): Promise<void> => {\n    try {\n        return await operation();\n    } catch (error) {\n        rejector(error);\n    }\n};\n","/** @format */\nimport { join, resolve } from 'node:path';\n\n/**\n * @utility\n * @description\n * Utility method to construct a absolute path from a given array of\n * path fragments starting from the root of the project.\n * @param { string[] } fragments - path fragments to construct the path from the root\n * @returns { string } the constructed absolute path.\n */\n\nexport const __root = (...fragments: string[]): string => {\n    return resolve(join(process.cwd(), ...fragments));\n};\n","/** @format */\n\nexport const isTruthy = (value: unknown) => (value ? true : false);\n","/** @format */\n\nexport const sortByProperty = <T>(property: keyof T, order: 'ASC' | 'DESC') => {\n    return (first: T, second: T) => {\n        let sortOrder = order === 'ASC' ? 1 : -1;\n        return (first[property] < second[property] ? -1 : first[property] > second[property] ? 1 : 0) * sortOrder;\n    };\n};\n","/** @format */\n\nconst chars = [...'abcdefghijklmnopqrstuvwxyz0123456789'];\n\nexport class ObjectId {\n    /**\n     * @static\n     * @description\n     * Static method to convert a raw string into an ObjectId. The string should conform\n     * to the ObjectId format of\n     * @param { string } raw - a raw string to convert to an ObjectId\n     * @returns { ObjectId } the newly created ObjectId\n     */\n\n    static from(raw: string): ObjectId {\n        ObjectId.is(raw);\n        const [timestamp, unique] = raw.split(':');\n\n        const id = new ObjectId();\n        id.timestamp = timestamp;\n        id.#unique = unique;\n\n        return id;\n    }\n\n    /**\n     * @static\n     * @throws\n     * @description\n     * Static method to check if a given value can be converted to an ObjectId.\n     * Throws an error if the passed value does not conform to the needed format.\n     *\n     * @param { unknown } value - the value to check for being an ObjectId\n     * @returns { boolean } true if the value is a string that can be converted to an ObjectId\n     */\n\n    static is(value: unknown): boolean {\n        if (typeof value !== 'string') {\n            throw new TypeError(`[ObjectId] Value \"${value}\" is of type ${typeof value}. Expected type string.`);\n        }\n\n        const [timestamp, unique] = value.split(':');\n\n        if (!value.includes(':')) {\n            throw new Error(`[ObjectId] Value \"${value}\" is not in the correct format.`);\n        }\n\n        if (!timestamp || !/[0-9]{6,6}/g.test(timestamp)) {\n            throw new Error(\n                `[ObjectId] Value \"${value}\" is not in the correct format. 'Timestamp' is missing or of incorrect length or NaN.`\n            );\n        }\n\n        if (!unique || !/[aA-zZ0-9]{24,24}/.test(unique)) {\n            throw new Error(\n                `[ObjectId] Value \"${value}\" is not in the correct format. 'Unique' is missing or of incorrect length.`\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * @static\n     * @description\n     * Static method to compare two ObjectIds for equality\n     *\n     * @param { ObjectId } actual\n     * @param { ObjectId } toCompare\n     * @returns { boolean } a boolean indicating if the two ObjectIds match.\n     */\n\n    static compare(actual: ObjectId, toCompare: ObjectId): boolean {\n        return actual.str === toCompare.str;\n    }\n\n    #timestamp: string = this.createTimestamp();\n    #unique: string = this.createUnique();\n\n    private getRandomCharIndex(ceil: number): number {\n        return Math.floor(Math.random() * ceil) * 1;\n    }\n\n    private convertToUppercase(char: string) {\n        return [char, char.toUpperCase()];\n    }\n\n    private createTimestamp(): string {\n        return Date.now().toString().slice(-7, -1).padStart(6, '7');\n    }\n\n    private createUnique(): string {\n        const uniqueChars = chars.flatMap(this.convertToUppercase);\n        return Array.apply(null, Array(24))\n            .map(() => uniqueChars[this.getRandomCharIndex(uniqueChars.length)])\n            .join('');\n    }\n\n    /**\n     * @type { string }\n     * @description\n     * The added timestamp of the ObjectId to increase uniqueness.\n     */\n\n    set timestamp(value: string) {\n        this.#timestamp = value.slice(0, 6).padEnd(6, '7');\n    }\n\n    get timestamp(): string {\n        return this.#timestamp;\n    }\n\n    /**\n     * @type { string }\n     * @description\n     * The unique identifier part of the ObjectId.\n     */\n\n    public set unique(value: string) {\n        this.#unique = value.slice(0, 16);\n    }\n\n    public get unique(): string {\n        return this.#unique;\n    }\n\n    private get id(): string {\n        return this.#timestamp + ':' + this.#unique;\n    }\n\n    /**\n     * @type { string }\n     * @description\n     * Return the Id of the ObjectId as string.\n     */\n\n    public get str(): string {\n        return this.id;\n    }\n\n    /**\n     * @description\n     * Method to retrieve the ObjectId as a string.\n     * @returns { string } the id string of the ObjectId.\n     */\n    public valueOf(): string {\n        return this.str;\n    }\n}\n","/** @format */\nimport { DocumentInit, Document } from '../types';\nimport { ObjectId } from './ObjectId';\n\nexport class JSONDocument<T extends Record<string, unknown>> {\n    data: T;\n    #id: ObjectId;\n    constructor(data: DocumentInit<T>) {\n        this.#id = data._id ? ObjectId.from(data._id) : new ObjectId();\n        delete data._._id;\n        this.data = { ...data._ };\n    }\n\n    get id() {\n        return this.#id;\n    }\n\n    /**\n     * @public\n     * @method\n     * @description\n     * Method to convert the internal data of the `JSONDocument` into a JSON\n     * encoded string to store inside a serialized file.\n     *\n     * @returns { string } the JSON encoded string to store as file\n     */\n\n    toFile(): string {\n        return JSON.stringify({ _id: this.#id.str, _: this.data });\n    }\n\n    /**\n     * @public\n     * @method\n     * @description\n     * Method to convert the internal data of the `JSONDocument` into a JS Object containing\n     * data and the exposed id\n     *\n     * @returns { string } the JSON encoded string to store as file\n     */\n\n    toDoc(): Document<T> {\n        return { ...this.data, _id: this.#id };\n    }\n}\n","/** @format */\n\nimport type { QueueTask } from '../types';\n\nexport class Queue {\n    #queue: Array<QueueTask> = [];\n    #executing: boolean = false;\n\n    public enqueue<T>(promise: Promise<T>): Promise<T> {\n        return new Promise((resolve, reject) => {\n            this.#queue.push({\n                execute: () => promise,\n                resolve,\n                reject,\n            });\n\n            this.dequeue();\n        });\n    }\n\n    public dequeue() {\n        if (this.#executing) return;\n\n        const task = this.#queue.shift();\n        if (!task) return;\n\n        try {\n            this.#executing = true;\n            task.execute()\n                .then((result) => this.resolveTask(task, result))\n                .catch((err) => this.rejectTask(task, err));\n        } catch (err) {\n            this.rejectTask(task, err);\n        }\n    }\n\n    private resolveTask(task: QueueTask, result: unknown) {\n        this.#executing = false;\n        task.resolve(result);\n        this.dequeue();\n    }\n\n    private rejectTask(task: QueueTask, reason: unknown) {\n        this.#executing = false;\n        task.reject(reason);\n        this.dequeue();\n    }\n\n    get pending() {\n        return this.#queue.length > 0;\n    }\n\n    get tasks() {\n        return this.#queue.length;\n    }\n}\n","/** @format */\n\nimport { type } from 'os';\nimport { FindOptions, Document } from '../../types';\nimport { FindByProperty } from '../../types/FindByProperty';\n\n/**\n * @description\n * Function to evaluate a `Document` using a given set of find options.\n *\n * @param { Document } document - the `Document`whose properties to check\n * @param { FindOptions } findOptions - the passed find options to evaluate\n * @returns { boolean } a boolean indicating if the `Document` satisfies the\n * conditions in the find options\n */\n\nexport const evaluateFindOptions = <T extends Record<string, unknown>>(\n    document: Document<T>,\n    findOptions: FindOptions<T>\n): boolean => {\n    return ([findOptions.where].flat() as FindByProperty<T>[]).some((findOption) => {\n        return Object.entries(findOption).every(([prop, evaluator]) => {\n            return typeof evaluator === 'function' ? evaluator(document[prop], prop) : document[prop] === evaluator;\n        });\n    });\n};\n","/** @format */\nimport { CipherKey, createCipheriv, createDecipheriv, createHash, randomBytes, BinaryLike } from 'crypto';\n\nexport class Crypto {\n    #algorithm = 'aes-256-cbc';\n    #vectorLength = 16;\n    constructor(private _key: string) {}\n\n    get key(): CipherKey {\n        return createHash('sha256').update(this._key).digest('base64').substring(0, 32);\n    }\n\n    encrypt(string: string): string {\n        const vector = randomBytes(this.#vectorLength);\n        const cipher = createCipheriv(this.#algorithm, this.key, vector);\n        const encrypted = Buffer.concat([cipher.update(string), cipher.final()]);\n\n        return JSON.stringify({\n            vector: vector.toString('hex'),\n            content: encrypted.toString('hex'),\n        });\n    }\n\n    decrypt(string: string): string {\n        const { content, vector } = JSON.parse(string);\n        const decipher = createDecipheriv(this.#algorithm, this.key, Buffer.from(vector, 'hex'));\n\n        return Buffer.concat([decipher.update(Buffer.from(content, 'hex')), decipher.final()]).toString();\n    }\n}\n","/** @format */\n\nimport { __root, safeAsyncAbort, isTruthy, sortByProperty } from '../utils';\nimport { Flotsam } from './Flotsam';\nimport { readdir, mkdir, rm, stat, readFile, writeFile } from 'node:fs/promises';\nimport { existsSync } from 'node:fs';\nimport { ObjectId } from './ObjectId';\nimport { JSONDocument } from './JSONDocument';\nimport { resolve } from 'node:path';\nimport { Queue } from './Queue';\nimport type { Document, Rejector, FindOptions } from '../types';\nimport { evaluateFindOptions } from './evaluateFindOptions';\nimport { FindByProperty } from '../types/FindByProperty';\nimport { Crypto } from './Crypto';\n\nexport class Collection<T extends Record<string, unknown>> {\n    #dir: string;\n    #files: string[] = [];\n    #documents: Map<string, JSONDocument<T>> = new Map();\n    #queue: Queue = new Queue();\n    #crypt: Crypto | null = null;\n    constructor(private ctx: Flotsam, private namespace: string) {\n        this.#dir = resolve(ctx.root, this.namespace);\n        this.#crypt = ctx.auth ? new Crypto(ctx.auth) : null;\n\n        process.on('SIGINT', async () => {\n            await this.serialize();\n        });\n\n        process.on('SIGTERM', async () => {\n            await this.serialize();\n        });\n    }\n\n    /**\n     * @type { Promise<number> }\n     * @description\n     * Returns the number of `Documents` currently in the collection.\n     */\n\n    get count(): Promise<number> {\n        return this.#queue.enqueue(\n            new Promise((res, rej) => {\n                res([...this.#documents.values()].length);\n            })\n        );\n    }\n\n    /**\n     * @type { Promise<Document[]> }\n     * @description\n     * Returns a copy of all `Documents` in the collection.\n     */\n\n    get entries(): Promise<Array<Document<T>>> {\n        return this.#queue.enqueue(\n            new Promise((res, rej) => {\n                res([...this.#documents.values()].map((doc) => ({ ...doc.toDoc() })));\n            })\n        );\n    }\n\n    /**\n     * @private\n     * @method\n     * @description\n     * Private method to create a rejector by binding a `Promise` rejection context to a function.\n     *\n     * @param { Rejector } reject - the `reject` function of a `Promise`\n     * @returns { Rejector } a function to reject and emit errors\n     */\n\n    private rejector(reject: Rejector): Rejector {\n        return (error: unknown) => {\n            this.ctx.emit('error', error);\n            reject(error);\n        };\n    }\n\n    /**\n     * @public\n     * @method\n     * @description\n     * Method used to deserialize the collection. This will load all records\n     * stored in the namespaced folder into the internal cache.\n     *\n     * @returns { Promise<boolean> } true if the deserialization is successful\n     */\n\n    async deserialize(): Promise<boolean> {\n        return this.#queue.enqueue(\n            new Promise(async (res, rej) => {\n                return safeAsyncAbort(this.rejector(rej), async () => {\n                    if (!existsSync(this.#dir)) {\n                        await mkdir(this.#dir);\n                    }\n\n                    // get all documents inside the dir\n                    this.#files = (await readdir(this.#dir)).filter((file) => ObjectId.is(file));\n\n                    for await (const document of this.#files) {\n                        let content = await readFile(resolve(this.#dir, document), 'utf-8');\n                        if (this.#crypt) content = this.#crypt.decrypt(content);\n\n                        const doc: { _: T; _id: string } = JSON.parse(content);\n                        this.#documents.set(\n                            ObjectId.from(doc._id).str,\n                            new JSONDocument<T>({ _id: document, _: doc._ })\n                        );\n                    }\n\n                    this.ctx.emit('deserialize', this);\n                    res(true);\n                });\n            })\n        );\n    }\n\n    /**\n     * @public\n     * @method\n     * @description\n     * Method used to serialize the collection. This will store all objects in the\n     * internal cache as record in the namespaced folder.\n     *\n     * @returns { Promise<boolean> } true if the serialization is successful\n     */\n\n    async serialize(): Promise<boolean> {\n        return this.#queue.enqueue(\n            new Promise(async (res, rej) => {\n                return safeAsyncAbort(this.rejector(rej), async () => {\n                    if (!existsSync(this.#dir)) {\n                        await mkdir(this.#dir);\n                    }\n\n                    for await (const [id, document] of [...this.#documents.entries()]) {\n                        const path = resolve(this.#dir, id);\n                        let content = document.toFile();\n                        if (this.#crypt) content = this.#crypt.encrypt(content);\n\n                        await writeFile(path, content, 'utf-8');\n                    }\n\n                    this.ctx.emit('serialize', this);\n                    res(true);\n                });\n            })\n        );\n    }\n\n    /**\n     * @public\n     * @method\n     * @description\n     * Drops the collection and removes all physical `Documents` stored on disk.\n     *\n     * @returns { Promise<boolean> } true if the collection was successfully dropped\n     */\n\n    async jettison(): Promise<boolean> {\n        return this.#queue.enqueue(\n            new Promise(async (res, rej) => {\n                return safeAsyncAbort(this.rejector(rej), async () => {\n                    await rm(this.#dir, { recursive: true, force: true });\n                    this.ctx.emit('drop', this);\n\n                    res(true);\n                });\n            })\n        );\n    }\n\n    //@Insert Operations\n\n    private async insert(document: JSONDocument<T>) {\n        return this.#queue.enqueue(\n            new Promise(async (res, rej) => {\n                let content = document.toFile();\n                if (this.#crypt) content = this.#crypt.encrypt(content);\n\n                const path = resolve(this.#dir, document.id.str);\n                await writeFile(path, content, 'utf-8');\n\n                this.#documents.set(document.id.str, document);\n\n                this.ctx.emit('insert', document.toDoc());\n\n                return res(true);\n            })\n        );\n    }\n\n    /**\n     * @description\n     * Inserts a `Document` into the database.\n     *\n     * @param { Record<string, unknown> } data - the data to insert as `Document`\n     * @returns { Promise<Document> } the created Document\n     */\n\n    async insertOne(data: T): Promise<Document<T> | false> {\n        return this.#queue.enqueue(\n            new Promise((res, rej) => {\n                return safeAsyncAbort(this.rejector(rej), async () => {\n                    const doc = new JSONDocument({ _: data });\n                    const inserted = await this.insert(doc);\n\n                    res(inserted ? doc.toDoc() : false);\n                });\n            })\n        );\n    }\n\n    async insertMany(...data: T[]): Promise<Document<T>[] | false> {\n        return this.#queue.enqueue(\n            new Promise((res, rej) => {\n                return safeAsyncAbort(this.rejector(rej), async () => {\n                    const docs = data.map((doc) => new JSONDocument({ _: doc }));\n                    const success = await Promise.all(\n                        docs.map(async (doc) => {\n                            return await this.insert(doc);\n                        })\n                    );\n\n                    res(success.every(isTruthy) ? docs.map((doc) => doc.toDoc()) : false);\n                });\n            })\n        );\n    }\n\n    // @Delete Operations\n\n    private async delete(id: string): Promise<boolean> {\n        return this.#queue.enqueue(\n            new Promise(async (res) => {\n                this.#documents.delete(id);\n                await rm(resolve(this.#dir, id));\n                this.ctx.emit('delete');\n                res(true);\n            })\n        );\n    }\n\n    /**\n     * @description\n     * Method to delete the first found `Document` by a given id. Returns the deleted `Document`\n     * or false, if no `Document` was found.\n     *\n     * @param { string } id - the id to the find the `Document` by.\n     * @returns { Promise<Document | false> } the deleted `Document` or false, if no `Document` was found.\n     */\n\n    async deleteOneById(id: string): Promise<Document<T> | false> {\n        return this.#queue.enqueue(\n            new Promise((res, rej) => {\n                return safeAsyncAbort(this.rejector(rej), async () => {\n                    const item = [...this.#documents.entries()].find(([key]) =>\n                        ObjectId.compare(ObjectId.from(key), ObjectId.from(id))\n                    );\n\n                    if (item === undefined) {\n                        return res(false);\n                    }\n\n                    const deleted = await this.delete(item[0]);\n\n                    return res(deleted ? item[1].toDoc() : false);\n                });\n            })\n        );\n    }\n\n    /**\n     * @description\n     * Method to delete the first found `Document` by a given set of find options. Returns the deleted `Document`\n     * or false, if no `Document` was found.\n     *\n     * @param { FindOptions } findOptions - the find options to the find the `Document` by.\n     * @returns { Promise<Document | false> } the deleted `Document` or false, if no `Document` was found.\n     */\n\n    async deleteOne(findOptions: FindOptions<T>): Promise<Document<T> | false> {\n        return this.#queue.enqueue(\n            new Promise((res, rej) => {\n                return safeAsyncAbort(this.rejector(rej), async () => {\n                    const items = await this.getEntriesByFindOptions(findOptions);\n\n                    if (items[0] === undefined) {\n                        return res(false);\n                    }\n\n                    const deleted = await this.delete(items[0]._id.str);\n\n                    return res(deleted ? items[0] : false);\n                });\n            })\n        );\n    }\n\n    async deleteMany(findOptions: FindOptions<T>): Promise<Document<T>[] | false> {\n        return this.#queue.enqueue(\n            new Promise((res, rej) => {\n                return safeAsyncAbort(this.rejector(rej), async () => {\n                    const items = await this.getEntriesByFindOptions(findOptions);\n\n                    if (items.length === 0) {\n                        return res(false);\n                    }\n\n                    const deleted = await Promise.all(items.map(async (item) => this.delete(item._id.str)));\n\n                    return res(deleted.every(isTruthy) ? items : false);\n                });\n            })\n        );\n    }\n\n    //@Find Operations\n\n    private async getEntriesByFindOptions(findOptions: FindOptions<T>): Promise<Document<T>[]> {\n        return this.#queue.enqueue(\n            new Promise((res, rej) => {\n                return safeAsyncAbort(this.rejector(rej), async () => {\n                    let items = [...this.#documents.entries()]\n                        .filter(([, value]) => evaluateFindOptions(value.toDoc(), findOptions))\n                        .map(([, doc]) => doc.toDoc());\n\n                    if (findOptions.order) {\n                        const { by, property } = findOptions.order;\n                        if (by && property) items.sort(sortByProperty(property, by));\n                    }\n\n                    if (findOptions.skip) {\n                        items = items.slice(findOptions.skip, -1);\n                    }\n\n                    if (findOptions.take) {\n                        items.length = findOptions.take;\n                    }\n\n                    if (findOptions.limit && items.length > findOptions.limit) {\n                        items.length = findOptions.limit;\n                    }\n\n                    res(items);\n                });\n            })\n        );\n    }\n\n    /**\n     * @description\n     * Method to select the first `Document` from the collection that satisfies it's id.\n     *\n     * @param { string } id - the id of the `Document` to select\n     * @returns {Promise<Document | null>} the first found `Document` or null if none was found\n     */\n\n    async findOneById(id: string): Promise<Document<T> | null> {\n        return this.#queue.enqueue(\n            new Promise((res, rej) => {\n                return safeAsyncAbort(this.rejector(rej), async () => {\n                    const item = [...this.#documents.entries()].find(([key]) =>\n                        ObjectId.compare(ObjectId.from(key), ObjectId.from(id))\n                    );\n\n                    if (item === undefined) {\n                        return res(null);\n                    }\n\n                    return res(item[1].toDoc());\n                });\n            })\n        );\n    }\n\n    /**\n     * @description\n     * Collection method to select the first `Document` according to the given find options.\n     *\n     * -----\n     *\n     *@example\n     * ```ts\n     * import { Flotsam } from \"flotsam\";\n     * import { Like } from \"flotsam/evaluator\"\n     *\n     * const collection = await db.collect<{ name: string }>('collection')\n     *\n     * // Search for the first Document containing a `name` property including 'flotsam'\n     * const result = await collection.findOne({ where: {name: Like('flotsam') }});\n     * ```\n     * ---\n     *\n     * @param { FindOptions } findOptions - the given FindOptions to select `Documents` by.\n     * @returns { Promise<Document[]> } an Array of Documents.\n     */\n    async findOne(findOptions: FindOptions<T>): Promise<Document<T> | null> {\n        return this.#queue.enqueue(\n            new Promise((res, rej) => {\n                return safeAsyncAbort(this.rejector(rej), async () => {\n                    const item = await this.getEntriesByFindOptions(findOptions);\n\n                    if (item[0] === undefined) {\n                        return res(null);\n                    }\n\n                    return res(item[0]);\n                });\n            })\n        );\n    }\n\n    /**\n     * @description\n     * Collection method to select the first `Document` according to the given simplified find by property options.\n     *\n     * -----\n     *\n     *@example\n     * ```ts\n     * import { Flotsam } from \"flotsam\";\n     * import { Like } from \"flotsam/evaluator\"\n     *\n     * const collection = await db.collect<{ name: string }>('collection')\n     *\n     * // Search for the first Document containing a `name` property including 'flotsam'\n     * const result = await collection.findOneBy({name: Like('flotsam')});\n     * ```\n     * ---\n     *\n     * @param { FindByProperty } findOptions - the given simplified FindByProperty options to select `Documents` by.\n     * @returns { Promise<Document> } an Array of Documents.\n     */\n\n    async findOneBy(findOptions: FindByProperty<T>): Promise<Document<T> | null> {\n        return this.#queue.enqueue(\n            new Promise((res, rej) => {\n                return safeAsyncAbort(this.rejector(rej), async () => {\n                    const item = await this.getEntriesByFindOptions({ where: findOptions });\n\n                    if (item[0] === undefined) {\n                        return res(null);\n                    }\n\n                    return res(item[0]);\n                });\n            })\n        );\n    }\n\n    /**\n     * @description\n     * Collection method to select a number of `Documents` according to the given find options.\n     *\n     * -----\n     *\n     *@example\n     * ```ts\n     * import { Flotsam } from \"flotsam\";\n     * import { Like } from \"flotsam/evaluator\"\n     *\n     * const collection = await db.collect<{ name: string }>('collection')\n     *\n     * // Search for any number of Documents containing a `name` property including 'flotsam'\n     * const result = await collection.findMany({ where: {name: Like('flotsam') }});\n     * ```\n     *\n     * Results can be ordered by any property present in the `Document`.\n     *\n     * ```ts\n     * // Perform the same search, but order the `Documents` by their first character.\n     * const result = await collection.findMany({ where : { name: Like('flotsam') }, order: { by: 'name', order: 'ASC' }})\n     *```\n     *\n     * Results can also be paginated, by skipping and taking. Skip and take can both be used independent of each other.\n     *\n     * ```ts\n     * // Perform the same search, but skip the first ten `Documents` found, and only take ten results\n     * const result = await collection.findMany({ where: { name: Like('flotsam') }, skip: 10, take: 10 })\n     * ```\n     *\n     * Results can be limited. Any limit will be applied after taking and skipping.\n     *\n     * ```ts\n     * // Perform the same search, but return only 100 `Documents`, if found more.\n     * const result = await collection.findMany({ where: { name: Like('flotsam') }, limit: 100 })\n     * ```\n     * ---\n     *\n     * @param { FindOptions } findOptions - the given FindOptions to select `Documents` by.\n     * @returns { Promise<Document[]> } an Array of Documents.\n     */\n\n    async findMany(findOptions: FindOptions<T>): Promise<Document<T>[]> {\n        return this.#queue.enqueue(\n            new Promise((res, rej) => {\n                return safeAsyncAbort(this.rejector(rej), async () => {\n                    return res(await this.getEntriesByFindOptions(findOptions));\n                });\n            })\n        );\n    }\n\n    /**\n     * @description\n     * Collection method to select a number of `Documents` according to the given simplified find by property options.\n     * The `findManyBy` method does not support ordering, taking, skipping or limiting the results.\n     *\n     * -----\n     *\n     *@example\n     * ```ts\n     * import { Flotsam } from \"flotsam\";\n     * import { Like } from \"flotsam/evaluator\"\n     *\n     * const collection = await db.collect<{ name: string }>('collection')\n     *\n     * // Search for any number of Documents containing a `name` property including 'flotsam'\n     * const result = await collection.findManyBy({name: Like('flotsam')});\n     * ```\n     * ---\n     *\n     * @param { FindByProperty } findOptions - the given simplified FindByProperty options to select `Documents` by.\n     * @returns { Promise<Document[]> } an Array of Documents.\n     */\n\n    async findManyBy(findOptions: FindByProperty<T>): Promise<Document<T>[]> {\n        return this.#queue.enqueue(\n            new Promise((res, rej) => {\n                return safeAsyncAbort(this.rejector(rej), async () => {\n                    return res(await this.getEntriesByFindOptions({ where: findOptions }));\n                });\n            })\n        );\n    }\n\n    //@Update Operations\n\n    /**\n     * @private\n     * @description\n     * Internal method to update a `Document`\n     *\n     * @param { Document } document - the found Document to update\n     * @param { Partial<any> } data - the data to update the document with\n     *\n     * @returns { Promise<Document> }\n     */\n\n    private async update(document: Document<T>, data: Partial<T>): Promise<Document<T>> {\n        return this.#queue.enqueue(\n            new Promise(async (res, rej) => {\n                const updated = new JSONDocument({ _id: document._id.str, _: { ...document, ...data } });\n                this.#documents.set(document._id.str, updated);\n\n                let content = updated.toFile();\n                if (this.#crypt) content = this.#crypt.encrypt(content);\n                await writeFile(resolve(this.#dir, document._id.str), content, 'utf8');\n\n                return res(updated.toDoc());\n            })\n        );\n    }\n\n    /**\n     * @description\n     * Method to select the first `Document` from the collection that satisfies it's id\n     * and update it with the given data.\n     *\n     * @param { string } id - the string to find the `Document` by.\n     * @param { Record<string, unknown> } data - the data to update the `Document` with.\n     * @returns { Promise<Document | false> } a Promise containing the updated `Document`\n     * or false, indicating that no `Document was found`.\n     */\n\n    async updateOneById(id: string, data: Partial<T>): Promise<Document<T> | false> {\n        return this.#queue.enqueue(\n            new Promise((res, rej) => {\n                return safeAsyncAbort(this.rejector(rej), async () => {\n                    const item = [...this.#documents.entries()].find(([key]) =>\n                        ObjectId.compare(ObjectId.from(key), ObjectId.from(id))\n                    );\n\n                    if (item === undefined) {\n                        return res(false);\n                    }\n\n                    const updated = await this.update(item[1].toDoc(), data);\n\n                    return res(updated);\n                });\n            })\n        );\n    }\n\n    /**\n     * @description\n     * Method to select the first `Document` from the collection that satisfies a given set\n     * of find options and update it with the given data.\n     *\n     * @param { FindOptions } findOptions - the find options to find the `Document` by.\n     * @param { Record<string, unknown> } data - the data to update the `Document` with.\n     * @returns { Promise<Document | false> } a Promise containing the updated `Document`\n     * or false, indicating that no `Document was found`.\n     */\n\n    async updateOne(findOptions: FindOptions<T>, data: Partial<T>): Promise<Document<T> | false> {\n        return this.#queue.enqueue(\n            new Promise((res, rej) => {\n                return safeAsyncAbort(this.rejector(rej), async () => {\n                    const items = await this.getEntriesByFindOptions(findOptions);\n\n                    if (items.length === 0) {\n                        return res(false);\n                    }\n\n                    const updated = await this.update(items[0], data);\n\n                    return res(updated);\n                });\n            })\n        );\n    }\n\n    /**\n     * @description\n     * Method to select the first `Document` from the collection that satisfies a given set\n     * of find simplified options and update it with the given data.\n     *\n     * @param { FindByProperty } findOptions - the find options to find the `Document` by.\n     * @param { Record<string, unknown> } data - the data to update the `Document` with.\n     * @returns { Promise<Document | false> } a Promise containing the updated `Document`\n     * or false, indicating that no `Document was found`.\n     */\n\n    async updateOneBy(findOptions: FindByProperty<T>, data: Partial<T>): Promise<Document<T> | false> {\n        return this.#queue.enqueue(\n            new Promise((res, rej) => {\n                return safeAsyncAbort(this.rejector(rej), async () => {\n                    const items = await this.getEntriesByFindOptions({ where: findOptions });\n\n                    if (items.length === 0) {\n                        return res(false);\n                    }\n\n                    const updated = await this.update(items[0], data);\n\n                    return res(updated);\n                });\n            })\n        );\n    }\n\n    async updateMany(findOptions: FindOptions<T>, data: Partial<T>): Promise<Document<T>[] | false> {\n        return this.#queue.enqueue(\n            new Promise((res, rej) => {\n                return safeAsyncAbort(this.rejector(rej), async () => {\n                    const items = await this.getEntriesByFindOptions(findOptions);\n\n                    if (items.length === 0) {\n                        return res(false);\n                    }\n\n                    const updated = await Promise.all(items.map(async (item) => await this.update(item, data)));\n\n                    return res(updated.every(isTruthy) ? updated : false);\n                });\n            })\n        );\n    }\n}\n","/** @format */\n\nimport { existsSync } from 'node:fs';\nimport { appendFile, readFile, stat, writeFile } from 'node:fs/promises';\nimport { resolve } from 'node:path';\nimport { __root } from '../utils';\nimport { Flotsam } from './Flotsam';\n\nexport class Loq {\n    #maxSafeFileSize: number = 157286400;\n    constructor(private ctx: Flotsam) {}\n\n    private async writeToFile(message: string) {\n        if (this.ctx.quiet || !this.ctx.log) return;\n\n        const destination = resolve(this.ctx.root, this.ctx.log);\n\n        if (!existsSync(destination)) {\n            await writeFile(destination, '', 'utf-8');\n        }\n\n        const { size } = await stat(destination);\n        let lines = (await readFile(destination, 'utf-8')).split('\\n');\n\n        if (size > this.#maxSafeFileSize) {\n            lines = lines.filter((_, i) => i > 100);\n            await writeFile(destination, lines.join('\\n'), 'utf-8');\n        }\n\n        await appendFile(destination, message, 'utf-8');\n    }\n\n    private get timestamp(): string {\n        return new Date().toUTCString().replace(',', ':');\n    }\n\n    error(error: string) {\n        this.writeToFile(`[ERROR]:[${this.timestamp}] - ${error}\\n`);\n    }\n\n    message(content: string) {\n        this.writeToFile(`[INFO]:[${this.timestamp}] - ${content}\\n`);\n    }\n}\n","/** @format */\n\nimport { mkdir } from 'node:fs/promises';\nimport { existsSync } from 'node:fs';\nimport { __root } from '../utils';\nimport { FlotsamInit, FlotsamEvent, Unsubscriber, Subscriber, Callback, ErrorHandler } from '../types';\nimport { Collection } from './Collection';\nimport { Loq } from './Loq';\nimport { Queue } from './Queue';\n\nexport class Flotsam {\n    /**\n     * @type { string }\n     * @description\n     * The absolute path of the directory to use as storage for the json documents\n     */\n    root: string;\n\n    /**\n     * @type { boolean }\n     * @description\n     * Boolean indicating if the database has been connected successfully.\n     */\n    connected: boolean = false;\n\n    /**\n     * @type { Record<string, Collection<any>> }\n     * @private\n     * @description\n     * Object holding all deserialized collections\n     */\n\n    #collections: Record<string, Collection<any>> = {};\n\n    auth?: string;\n\n    quiet?: boolean = true;\n\n    log?: string;\n\n    #loq: Loq = new Loq(this);\n\n    #queue: Queue = new Queue();\n\n    #handlers: Record<FlotsamEvent, Array<Subscriber>> = {\n        close: [],\n        delete: [],\n        deserialize: [],\n        drop: [],\n        insert: [],\n        connect: [],\n        serialize: [],\n        update: [],\n        upsert: [],\n        error: [],\n    };\n\n    constructor(init: FlotsamInit) {\n        this.root = __root(init.root);\n        this.auth = init.auth;\n        this.quiet = init.quiet;\n        this.log = init.log;\n\n        this.createInitialListeners();\n    }\n\n    private createInitialListeners() {\n        this.on('error', (error) => {\n            return this.#queue.enqueue(\n                new Promise((res) => {\n                    return res(this.#loq.error(error));\n                })\n            );\n        });\n\n        this.on('connect', () => {\n            return this.#queue.enqueue(\n                new Promise((res) => {\n                    return res(this.#loq.message('[Flotsam] Connected'));\n                })\n            );\n        });\n\n        this.on('connect', () => {\n            this.connected = true;\n            !this.quiet && console.log(`ðŸ™ \\x1b[34m[Flotsam] DB Connected.\\x1b[0m`);\n        });\n\n        this.on('close', () => {\n            return this.#queue.enqueue(\n                new Promise((res) => {\n                    return res(this.#loq.message('[Flotsam] Closed'));\n                })\n            );\n        });\n\n        this.on('close', () => {\n            this.connected = false;\n            !this.quiet && console.log(`ðŸª¢  \\x1b[34m[Flotsam] DB Closed.\\x1b[0m`);\n        });\n    }\n\n    /**\n     * @description\n     * Method to initialize the Database. Check if the physical storage\n     * directory exists, and if not, create the necessary directories\n     * recursively.\n     *\n     * ```ts\n     * import { Flotsam } from \"flotsam\";\n     *\n     * const db = new Flotsam({ root: './.store' });\n     * await db.connect();\n     * ```\n     * @param { Callback | null } [callback] - optional callback that will be executed when the connection is completed.\n     * @param { ErrorHandler } [error] - optional error callback that will be executed when the connection fails.\n     *\n     * @returns { Promise<boolean> } `true` if the connection is established\n     */\n\n    async connect(callback?: Callback | null, error?: ErrorHandler): Promise<boolean> {\n        return new Promise(async (res, rej) => {\n            try {\n                /**\n                 * Check if the root dir passed in the initialization\n                 * object exists, if not create it.\n                 */\n\n                if (!existsSync(this.root)) {\n                    await mkdir(this.root, { recursive: true });\n                }\n\n                this.emit('connect');\n                if (callback && typeof callback === 'function') callback();\n                res(true);\n            } catch (e) {\n                this.emit('error', e);\n                if (error && typeof error === 'function') error(e);\n                rej(e);\n            }\n        });\n    }\n\n    /**\n     * @description\n     * Method to retrieve a Collection from the database. The collection is\n     * deserialized from the filesystem and cached.\n     *\n     * ```ts\n     * type User = { name: string; age: number }\n     *\n     * const users = await db.collect<User>('users');\n     * // users: Collection<User>\n     *\n     * users.findOneBy({ id: 1 })\n     * // returns a User with the id `1`\n     *\n     * users.insertOne({ name: 'Flotsam', age: 100 })\n     * // return a `Document<User>` object.\n     * ```\n     *\n     * @param { string } namespace - the namespace of the collection to retrieve.\n     * @returns { Collection } the deserialized Collection containing the entries stored\n     * previously.\n     */\n\n    async collect<T extends Record<string, unknown>>(namespace: string): Promise<Collection<T>> {\n        if (!this.#collections[namespace]) {\n            this.#collections[namespace] = new Collection<T>(this, namespace);\n            await this.#collections[namespace].deserialize();\n        }\n        return this.#collections[namespace];\n    }\n\n    /**\n     * @description\n     * Method to remove a collection from the physical storage directory or just the collection cache.\n     *\n     * @param { string } namespace - the namespace of the collection to drop.\n     * @param { boolean } [soft] - optional boolean indicating if the physical documents should be kept.\n     * @returns { Promise<boolean> } - true if the collection was successfully dropped.\n     */\n\n    async jettison(namespace: string, soft: boolean = false): Promise<boolean> {\n        if (!this.#collections[namespace]) return false;\n\n        if (!soft) {\n            await this.#collections[namespace].jettison();\n        }\n\n        delete this.#collections[namespace];\n        return true;\n    }\n\n    /**\n     * @description\n     * Method to gracefully shut down the database. Calling the `close` method will\n     * serialize all remaining `Collections`.\n     */\n\n    async close(): Promise<void> {\n        this.emit('close');\n        Object.values(this.#collections).forEach(async (collection) => {\n            await collection.serialize();\n        });\n    }\n\n    /**\n     * @description\n     * Method to subscribe to an event emitted by Flotsam during operation.\n     *\n     * ```ts\n     * const db = new Flotsam();\n     * db.on('close', () => { // do something })\n     * ```\n     *\n     * @param { FlotsamEvent } event - the event to subscribe to.\n     * @param { Subscriber } handler - the callback to execute when the event is emitted.\n     * @returns { Unsubscriber } a function to unsubscribe and cleanup the subscriber.\n     */\n\n    on(event: FlotsamEvent, handler: Subscriber): Unsubscriber {\n        this.#handlers[event].push(handler);\n\n        return () => {\n            this.#handlers[event] = this.#handlers[event].filter((h) => h !== handler);\n        };\n    }\n\n    /**\n     * @description\n     * Method to trigger callbacks registered via the `on` method.\n     *\n     * @param { FlotsamEvent } event - the eventname to emit.\n     * @param { any[] } args - optional arguments that are relayed to the handler function.\n     */\n\n    emit(event: FlotsamEvent, ...args: any[]): void {\n        this.#handlers[event].forEach((handler) => handler(...args));\n    }\n}\n"],"names":["resolve","join","createHash","randomBytes","createCipheriv","createDecipheriv","existsSync","mkdir","readdir","readFile","writeFile","rm","stat","appendFile"],"mappings":"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"}